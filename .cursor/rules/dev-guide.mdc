---
alwaysApply: true
---

# 你是一名高级前端架构师和开发工程师，当我输入需求的时候，请你按照 riper5 进行分析。同时遵循以下内容：

## 核心技术栈约束

### 框架版本要求

- **Taro**: 4.1.5 (稳定版本，不可随意升级)
- **React**: 18.x (使用新的 JSX 转换)
- **TypeScript**: 5.1.6 (严格模式)
- **Webpack**: 5.x (构建工具)

### 必须遵循的技术选型

- **状态管理**: Zustand是客户端状态管理 + React Query是API服务端数据状态管理 (禁止使用 Redux)
- **UI 组件**: Taro UI 3.3.0 (优先使用官方组件)
- **样式**: SCSS + PostCSS (禁止使用 CSS-in-JS)
- **HTTP**: Axios + MSW (开发环境 Mock)
- **包管理**: pnpm (禁止使用 npm/yarn)
- **代码规范检查**: prettier，eslint，stylelint
- **测试框架**: Jest
- **错误边界**: React ErrorBoundary
- **图标管理**: taro-iconfont-cli

## 参考文档

- **Taro 官方技术文档**: https://docs.taro.zone/docs/ 优先以官方文档的为准

## ⚠️ 注意事项

1. **避免在文件中编写临时脚本**，特别是只需运行一次的数据迁移脚本
2. **仅测试环境使用模拟数据**，开发与生产环境严禁使用Mock数据
3. **保持代码稳定性**，确保修改不会影响其他功能的正常运行
4. **编译检查**，完成功能后必须保证编译正常
5. **运行检查**，完成功能后必须保证正常运行和调试
6. **代码格式和规范检查**，完成功能后运行pnpm check，遇到规范和格式问题请修复
7. 使用真实的 UI 图片，而非占位符图片（可从 Unsplash、Pexels、Apple 官方 UI 资源中选择）
8. 当前项目是个移动端项目，只需要适配主流手机即可。可通过taro框架去控制。

## 强制性检查流程

### 开发完成后必须执行

```bash
# 1. 代码质量检查 (必须通过)
pnpm check

# 2. 自动修复问题
pnpm check:fix

# 3. 构建验证
pnpm build:h5

# 4. 测试验证
pnpm test
```

### 提交前检查清单

- [ ] `pnpm check` 无错误
- [ ] `pnpm build:h5` 构建成功
- [ ] `pnpm test` 测试通过
- [ ] 功能手动测试正常
- [ ] 代码已格式化

## 跨平台兼容性规则

### 尺寸单位规范

```scss
// ✅ 推荐：使用 px，Taro 会自动转换
.container {
  width: 375px;
  height: 200px;
  margin: 20px;
}

// ✅ 推荐：使用百分比
.flexible {
  width: 100%;
  height: 50%;
}

// ❌ 禁止：不要使用 rem、em、vw、vh
.wrong {
  width: 10rem; // 禁止
  height: 50vh; // 禁止
}
```

### 设计稿适配

- **设计稿宽度**: 375px (iPhone 标准)
- **设备比例配置**: 已在 [config/index.ts](mdc:config/index.ts) 中配置
- **响应式**: 通过 Taro 框架自动处理

### API 调用规范

```typescript
// ✅ 使用统一的 API 服务
import { userApi } from '@/services/api'

// ✅ 使用 React Query 管理状态
const { data, isLoading } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => userApi.getProfile(userId),
})

// ❌ 禁止直接使用 Taro.request
Taro.request({ url: '/api/user' }) // 禁止
```

## 平台特定注意事项

### 小程序限制

- 不能使用 `eval()` 和 `new Function()`
- 不能动态加载脚本
- 图片资源需要配置域名白名单
- 音频播放需要用户交互触发

### H5 特定

- 支持完整的 Web API
- 可以使用 localStorage
- 支持 Service Worker (MSW)

### 权限处理

```typescript
// ✅ 统一的权限请求
import Taro from '@tarojs/taro'

const requestRecordPermission = async () => {
  try {
    const result = await Taro.authorize({
      scope: 'scope.record',
    })
    return result.errMsg === 'authorize:ok'
  } catch (error) {
    // 处理权限拒绝
    return false
  }
}
```

## 组件架构规范

### 函数组件规范

```typescript
// ✅ 标准组件定义
import React from 'react'
import './index.scss'

interface ButtonProps {
  type?: 'primary' | 'secondary'
  size?: 'small' | 'normal' | 'large'
  disabled?: boolean
  loading?: boolean
  children: React.ReactNode
  onClick?: () => void
}

const Button: React.FC<ButtonProps> = ({
  type = 'primary',
  size = 'normal',
  disabled = false,
  loading = false,
  children,
  onClick
}) => {
  // 组件逻辑
  return (
    <view className={`button button--${type} button--${size}`}>
      {children}
    </view>
  )
}

export default Button
export type { ButtonProps }
```

### 组件文件结构

```
components/
├── Button/
│   ├── index.tsx      # 组件实现
│   ├── index.scss     # 组件样式
│   └── types.ts       # 类型定义 (可选)
```

## 状态管理规范

### Zustand Store 开发规范

#### 基础 Store 定义

```typescript
// ✅ 标准 Store 定义
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { queryClient } from '@/providers/QueryProvider'
import { QUERY_KEYS } from '@/hooks/useApiQueries'

interface UserState {
  // 状态数据
  user: User | null
  isLoggedIn: boolean
  profile: UserProfile

  // Actions（动作方法）
  setUser: (user: User) => void
  logout: () => void
  updateProfile: (updates: Partial<UserProfile>) => void
}

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      // 初始状态
      user: null,
      isLoggedIn: false,
      profile: defaultProfile,

      // Actions 实现
      setUser: (user: User) => {
        set({ user, isLoggedIn: true })
        // 同步更新 React Query 缓存
        queryClient.setQueryData(QUERY_KEYS.USER_PROFILE(), user)
      },

      logout: () => {
        set({ user: null, isLoggedIn: false })
        // 清除所有用户相关的缓存
        queryClient.removeQueries({ queryKey: QUERY_KEYS.USER })
      },

      updateProfile: (updates: Partial<UserProfile>) => {
        const currentProfile = get().profile
        const updatedProfile = { ...currentProfile, ...updates }
        set({ profile: updatedProfile })
        // 使相关查询失效
        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.USER_STATS })
      },
    }),
    {
      name: 'user-storage',
      // 只持久化必要的字段
      partialize: state => ({
        user: state.user,
        profile: state.profile,
        isLoggedIn: state.isLoggedIn,
      }),
    }
  )
)
```

#### Zustand 最佳实践

```typescript
// ✅ 使用 immer 处理复杂状态更新
import { immer } from 'zustand/middleware/immer'

export const useComplexStore = create<ComplexState>()(
  immer((set) => ({
    data: { nested: { value: 0 } },
    updateNested: (newValue: number) =>
      set((state) => {
        state.data.nested.value = newValue
      }),
  }))
)

// ✅ 状态分片 - 避免单个 store 过大
export const useUserStore = create<UserState>()(...) // 用户相关
export const useTopicStore = create<TopicState>()(...) // 话题相关
export const useVocabularyStore = create<VocabularyState>()(...) // 词汇相关

// ✅ 使用 subscribeWithSelector 进行精确订阅
import { subscribeWithSelector } from 'zustand/middleware'

export const useStore = create<State>()(
  subscribeWithSelector((set) => ({
    count: 0,
    increment: () => set((state) => ({ count: state.count + 1 })),
  }))
)

// 组件中精确订阅
const count = useStore((state) => state.count)
```

#### Zustand 与 React Query 集成规范

```typescript
// ✅ 在 Zustand actions 中同步 React Query 缓存
const setTopics: (topics: Topic[]) => {
  set({ topics })
  // 同步更新 React Query 缓存
  queryClient.setQueryData(QUERY_KEYS.TOPICS, topics)
}

// ✅ 预取相关数据
const setCurrentTopic: (topic: Topic | null) => {
  set({ currentTopic: topic })
  // 预取话题详情
  if (topic) {
    queryClient.prefetchQuery({
      queryKey: QUERY_KEYS.TOPIC_DETAIL(topic.id),
      queryFn: () => topicApi.getTopicDetail(topic.id),
    })
  }
}

// ✅ 清理缓存
const logout: () => {
  set({ user: null, isLoggedIn: false })
  // 清除所有用户相关缓存
  queryClient.removeQueries({ queryKey: QUERY_KEYS.USER })
  queryClient.removeQueries({ queryKey: QUERY_KEYS.USER_STATS })
}
```

### React Query 开发规范

#### Query Keys 管理

```typescript
// ✅ 统一的 Query Keys 定义
export const QUERY_KEYS = {
  // 用户相关
  USER: ['user'] as const,
  USER_PROFILE: (userId?: string) => ['user', 'profile', userId] as const,
  USER_STATS: ['user', 'stats'] as const,

  // 话题相关
  TOPICS: ['topics'] as const,
  TOPIC_DETAIL: (topicId: string) => ['topics', 'detail', topicId] as const,
  TOPIC_DIALOGUES: (topicId: string) =>
    ['topics', 'dialogues', topicId] as const,

  // 词汇相关
  VOCABULARIES: ['vocabularies'] as const,
  VOCABULARY_BY_LEVEL: (level: string) =>
    ['vocabularies', 'level', level] as const,
} as const
```

#### 查询 Hooks 规范

```typescript
// ✅ 标准查询 Hook
export const useUserInfo = () => {
  return useQuery({
    queryKey: QUERY_KEYS.USER_PROFILE(),
    queryFn: async () => {
      const response = await userApi.getUserInfo()
      return response.data // 返回实际数据，不是 ApiResponse 包装
    },
    staleTime: 10 * 60 * 1000, // 10分钟内认为数据是新鲜的
    gcTime: 30 * 60 * 1000, // 30分钟后清理缓存
  })
}

// ✅ 带参数的查询
export const useTopics = (category?: string, level?: string) => {
  return useQuery({
    queryKey: [...QUERY_KEYS.TOPICS, { category, level }],
    queryFn: async () => {
      const response = await topicApi.getTopics({ category, level })
      return response.data
    },
    enabled: true, // 可以根据条件控制是否启用
    staleTime: 15 * 60 * 1000,
  })
}

// ✅ 条件查询
export const useTopicDetail = (topicId: string) => {
  return useQuery({
    queryKey: QUERY_KEYS.TOPIC_DETAIL(topicId),
    queryFn: async () => {
      const response = await topicApi.getTopicDetail(topicId)
      return response.data
    },
    enabled: !!topicId, // 只有当 topicId 存在时才执行查询
    staleTime: 30 * 60 * 1000,
  })
}
```

#### 变更 Hooks 规范

```typescript
// ✅ 标准变更 Hook
export const useUpdateUserInfo = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (userInfo: Partial<User>) => {
      const response = await userApi.updateUserInfo(userInfo)
      return response.data
    },
    onSuccess: data => {
      // 更新用户信息缓存
      queryClient.setQueryData(QUERY_KEYS.USER_PROFILE(), data)
      // 使相关查询失效
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.USER })
    },
    onError: error => {
      // 统一错误处理
      console.error('更新用户信息失败:', error)
    },
  })
}

// ✅ 带乐观更新的变更
export const useToggleFavorite = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      topicId,
      isFavorite,
    }: {
      topicId: string
      isFavorite: boolean
    }) => topicApi.toggleFavorite(topicId, isFavorite),

    // 乐观更新
    onMutate: async ({ topicId, isFavorite }) => {
      // 取消正在进行的查询
      await queryClient.cancelQueries({ queryKey: QUERY_KEYS.TOPICS })

      // 保存之前的数据
      const previousTopics = queryClient.getQueryData(QUERY_KEYS.TOPICS)

      // 乐观更新
      queryClient.setQueryData(QUERY_KEYS.TOPICS, (old: Topic[]) =>
        old?.map(topic =>
          topic.id === topicId ? { ...topic, isFavorite } : topic
        )
      )

      return { previousTopics }
    },

    // 错误回滚
    onError: (err, variables, context) => {
      if (context?.previousTopics) {
        queryClient.setQueryData(QUERY_KEYS.TOPICS, context.previousTopics)
      }
    },

    // 最终同步
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.TOPICS })
    },
  })
}
```

#### React Query 配置规范

```typescript
// ✅ QueryClient 配置 - 参考 [src/providers/QueryProvider.tsx](mdc:src/providers/QueryProvider.tsx)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 数据保持新鲜的时间（5分钟）
      staleTime: 5 * 60 * 1000,
      // 缓存时间（30分钟）
      gcTime: 30 * 60 * 1000,
      // 重试配置
      retry: (failureCount, error: Error) => {
        // 网络错误重试，其他错误不重试
        if (error?.message?.includes('network') && failureCount < 3) {
          return true
        }
        return false
      },
      // 重试延迟（指数退避）
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      // 窗口重新获得焦点时不自动重新获取
      refetchOnWindowFocus: false,
      // 网络重连时重新获取
      refetchOnReconnect: true,
    },
    mutations: {
      // 变更重试配置
      retry: 1,
    },
  },
})
```

#### 数据预取和缓存策略

```typescript
// ✅ 数据预取工具
export const usePrefetchData = () => {
  const queryClient = useQueryClient()

  const prefetchUserData = (userId?: string) => {
    queryClient.prefetchQuery({
      queryKey: QUERY_KEYS.USER_PROFILE(userId),
      queryFn: () => userApi.getUserInfo(),
    })

    queryClient.prefetchQuery({
      queryKey: QUERY_KEYS.USER_STATS,
      queryFn: () => userApi.getStudyStats(),
    })
  }

  const prefetchTopics = () => {
    queryClient.prefetchQuery({
      queryKey: QUERY_KEYS.TOPICS,
      queryFn: () => topicApi.getTopics({}),
    })
  }

  return { prefetchUserData, prefetchTopics }
}

// ✅ 在组件中使用预取
const HomePage = () => {
  const { prefetchTopics } = usePrefetchData()

  useEffect(() => {
    // 预取用户可能需要的数据
    prefetchTopics()
  }, [prefetchTopics])

  return <div>...</div>
}
```

#### 错误处理和加载状态

```typescript
// ✅ 统一的错误处理
const UserProfile = () => {
  const {
    data: userInfo,
    isLoading,
    error,
    refetch
  } = useUserInfo()

  if (isLoading) {
    return <AtLoadMore status="loading" />
  }

  if (error) {
    return (
      <View className="error-container">
        <Text className="error-text">加载失败，请重试</Text>
        <View className="retry-button" onClick={() => refetch()}>
          重试
        </View>
      </View>
    )
  }

  return (
    <View>
      <Text>{userInfo?.nickname}</Text>
    </View>
  )
}

// ✅ 变更状态处理
const UpdateButton = () => {
  const updateUser = useUpdateUserInfo()

  const handleUpdate = async () => {
    try {
      await updateUser.mutateAsync({ nickname: '新昵称' })
      Taro.showToast({ title: '更新成功', icon: 'success' })
    } catch (error) {
      Taro.showToast({ title: '更新失败', icon: 'error' })
    }
  }

  return (
    <button
      onClick={handleUpdate}
      disabled={updateUser.isPending}
    >
      {updateUser.isPending ? '更新中...' : '更新'}
    </button>
  )
}
```

### 状态管理架构原则

#### 数据流设计

```
用户操作 → Zustand Action → 同步 React Query 缓存 → UI 更新
     ↓
API 调用 → React Query Hook → 自动缓存 → 后台更新
```

#### 职责分离

- **Zustand**: 管理客户端状态（UI 状态、用户偏好、临时数据）
- **React Query**: 管理服务端状态（API 数据、缓存、同步）
- **双向同步**: Zustand 更新时同步 React Query，React Query 数据变更时可选择性更新 Zustand

#### 缓存策略

```typescript
// ✅ 不同数据的缓存策略
const cacheStrategies = {
  // 用户信息 - 长缓存
  userInfo: { staleTime: 30 * 60 * 1000, gcTime: 60 * 60 * 1000 },

  // 话题列表 - 中等缓存
  topics: { staleTime: 15 * 60 * 1000, gcTime: 30 * 60 * 1000 },

  // 聊天消息 - 短缓存
  chatMessages: { staleTime: 2 * 60 * 1000, gcTime: 10 * 60 * 1000 },

  // 实时数据 - 不缓存
  liveData: { staleTime: 0, gcTime: 0 },
}
```

## API 和 Mock 开发规范

### MSW Mock 服务规范

```typescript
// ✅ 环境检测 - 参考 [src/app.ts](mdc:src/app.ts)
const isDev = process.env.NODE_ENV === 'development'

// 只在开发环境启用 MSW
if (isDev || window.location.hostname === 'localhost') {
  import('./mocks/browser').then(({ startWorker }) => {
    startWorker()
  })
}
```

### Mock Handler 定义

```typescript
// ✅ 标准 Mock Handler - 参考 [src/mocks/handlers/user.ts](mdc:src/mocks/handlers/user.ts)
import { http, HttpResponse } from 'msw'
import type { User } from '@/types'

export const userHandlers = [
  // GET 请求
  http.get('/api/user/profile', ({ request }) => {
    const url = new URL(request.url)
    const userId = url.searchParams.get('userId')

    return HttpResponse.json({
      code: 200,
      message: 'success',
      data: mockUser,
    })
  }),

  // POST 请求
  http.post('/api/user/update', async ({ request }) => {
    const body = await request.json()

    return HttpResponse.json({
      code: 200,
      message: 'success',
      data: { ...mockUser, ...body },
    })
  }),
]
```

### HTTP 客户端配置

```typescript
// ✅ HTTP 客户端 - 参考 [src/services/http.ts](mdc:src/services/http.ts)
class HttpClient {
  private instance: AxiosInstance

  constructor() {
    this.instance = axios.create({
      baseURL: config.apiConfig.baseURL,
      timeout: config.apiConfig.timeout,
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(config => {
      // 添加认证 token
      const token = getStorage('token')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      return config
    })

    // 响应拦截器
    this.instance.interceptors.response.use(
      response => response.data,
      error => {
        // 统一错误处理
        return Promise.reject(error)
      }
    )
  }
}
```

## 样式规范

### SCSS 命名规范 (BEM)

```scss
// ✅ BEM 命名规范
.button {
  // 基础样式

  &--primary {
    // 修饰符样式
  }

  &--large {
    // 尺寸修饰符
  }

  &__icon {
    // 元素样式
  }

  &--disabled {
    // 状态修饰符
  }
}
```

### 响应式设计

```scss
// ✅ 移动端优先
.container {
  padding: 20px;

  // 使用 Taro 的响应式 mixin
  @media (min-width: 768px) {
    padding: 40px;
  }
}
```

### 禁止的样式写法

```scss
// ❌ 禁止使用 !important
.button {
  color: red !important; // 禁止
}

// ❌ 禁止使用内联样式 (除非动态计算)
<div style="color: red"> // 禁止

// ❌ 禁止使用非标准单位
.container {
  width: 10rem; // 禁止，使用 px
  height: 50vh; // 禁止，使用 px
}
```

## TypeScript 严格模式

### 类型定义要求

```typescript
// ✅ 完整的接口定义
interface ButtonProps {
  type?: 'primary' | 'secondary' | 'danger'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  loading?: boolean
  children: React.ReactNode
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
}

// ✅ 泛型使用
interface ApiResponse<T> {
  code: number
  message: string
  data: T
}

// ✅ 联合类型
type Theme = 'light' | 'dark'
type UserRole = 'admin' | 'user' | 'guest'
```

### 禁止的类型使用

```typescript
// ❌ 禁止使用 any
const data: any = {} // 禁止

// ❌ 禁止使用 object
const config: object = {} // 禁止，使用具体接口

// ❌ 禁止使用 Function
const callback: Function = () => {} // 禁止，使用具体函数签名
```

## 移动端优化规范

### 触摸友好设计

```scss
// ✅ 最小触摸目标 44px
.touch-target {
  min-height: 44px;
  min-width: 44px;

  // 触摸反馈
  &:active {
    opacity: 0.7;
    transform: scale(0.98);
  }
}
```

### 性能优化

```typescript
// ✅ 图片懒加载
import { Image } from '@tarojs/components'

const OptimizedImage: React.FC<ImageProps> = ({
  src,
  placeholder,
  ...props
}) => {
  return (
    <Image
      src={src}
      lazyLoad
      mode="aspectFit"
      placeholder={placeholder}
      onError={(e) => {
        console.warn('图片加载失败:', e)
      }}
      {...props}
    />
  )
}
```

### 音频处理优化

```typescript
// ✅ 录音权限和功能
const useRecording = () => {
  const [isRecording, setIsRecording] = useState(false)

  const startRecording = useCallback(async () => {
    try {
      // 请求录音权限
      const authorized = await Taro.authorize({
        scope: 'scope.record',
      })

      if (authorized.errMsg !== 'authorize:ok') {
        throw new Error('录音权限被拒绝')
      }

      // 开始录音
      const recorderManager = Taro.getRecorderManager()
      recorderManager.start({
        duration: 60000, // 最长60秒
        sampleRate: 16000,
        numberOfChannels: 1,
        encodeBitRate: 48000,
        format: 'mp3',
      })

      setIsRecording(true)
    } catch (error) {
      console.error('录音启动失败:', error)
      Taro.showToast({
        title: '录音功能不可用',
        icon: 'none',
      })
    }
  }, [])

  return { isRecording, startRecording }
}
```

## 错误处理标准

### 页面级错误边界

```typescript
// 参考 [src/components/ErrorBoundary/PageErrorBoundary.tsx](mdc:src/components/ErrorBoundary/PageErrorBoundary.tsx)
export const withPageErrorBoundary = <P extends object>(
  Component: React.ComponentType<P>
) => {
  return (props: P) => (
    <PageErrorBoundary>
      <Component {...props} />
    </PageErrorBoundary>
  )
}
```

### 组件内错误处理

```typescript
const UserProfile = ({ userId }) => {
  const { data, error, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => userApi.getProfile(userId),
    onError: (error) => {
      handleApiError(error, { context: 'UserProfile' })
    }
  })

  if (error) {
    return <ErrorMessage message="加载用户信息失败" />
  }

  return <div>{data?.name}</div>
}
```

## 文件组织规范

### 目录结构要求

```
src/
├── components/          # 组件目录
│   ├── common/         # 通用组件
│   │   ├── Button/
│   │   │   ├── index.tsx
│   │   │   ├── index.scss
│   │   │   └── types.ts
│   │   └── Modal/
│   └── business/       # 业务组件
├── pages/              # 页面目录
│   ├── user/
│   │   ├── index.tsx
│   │   ├── index.scss
│   │   └── index.config.ts
├── services/           # API 服务
├── stores/            # 状态管理
├── utils/             # 工具函数
└── types/             # 类型定义
```

### 文件命名规范

- **组件文件**: PascalCase (Button.tsx, UserProfile.tsx)
- **页面文件**: kebab-case (user-profile/index.tsx)
- **工具文件**: camelCase (dateUtils.ts, apiHelper.ts)
- **类型文件**: camelCase (userTypes.ts, apiTypes.ts)

## 性能要求

### 组件性能优化

```typescript
// ✅ 使用 React.memo 避免不必要的重渲染
const UserCard = React.memo<UserCardProps>(({ user, onSelect }) => {
  const handleClick = useCallback(() => {
    onSelect(user.id)
  }, [user.id, onSelect])

  return (
    <div onClick={handleClick}>
      {user.name}
    </div>
  )
})

// ✅ 使用 useMemo 缓存计算结果
const ExpensiveComponent = ({ items }) => {
  const processedItems = useMemo(() => {
    return items.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }))
  }, [items])

  return <div>{processedItems.map(renderItem)}</div>
}
```

### 代码分割

```typescript
// ✅ 页面级代码分割
const LazyUserPage = lazy(() => import('@/pages/user'))
const LazySettingsPage = lazy(() => import('@/pages/settings'))

// ✅ 组件级代码分割 (大型组件)
const LazyChart = lazy(() => import('@/components/Chart'))
```

## 测试要求

### 单元测试覆盖率

- **最低要求**: 70%
- **目标覆盖率**: 80%+
- **关键组件**: 90%+

### 测试文件组织

```
__tests__/
├── components/
│   ├── Button.test.tsx
│   └── Modal.test.tsx
├── pages/
│   └── UserProfile.test.tsx
├── utils/
│   └── dateUtils.test.ts
└── services/
    └── api.test.ts
```

## 提交规范

### Git Commit 消息格式

```bash
# ✅ 标准格式
feat: 添加用户头像上传功能
fix: 修复登录页面验证码刷新问题
style: 优化按钮组件样式
refactor: 重构用户状态管理逻辑
test: 添加用户服务单元测试
docs: 更新 API 文档

# ❌ 不规范的提交消息
git commit -m "fix bug"        # 太简单
git commit -m "各种修改"        # 不明确
git commit -m "WIP"           # 不应提交未完成代码
```

## 通用开发原则

- **开发座右铭**: 简单、重用、稳定、可维护 🎯
- 始终优先选择简单方案
- 尽可能避免代码重复
    • 修改代码前，检查代码库中是否已存在相似功能或逻辑。
- 编写代码时需区分不同环境
    • 明确区分开发环境（dev）、测试环境（test）和生产环境（prod）。
- 谨慎修改代码
    • 仅针对明确需求进行更改，或确保修改内容与需求强相关且已被充分理解。
- 修复问题时避免引入新技术/模式
    • 优先彻底排查现有实现的可能性，若必须引入新方案，需同步移除旧逻辑以避免冗余。
- 保持代码库整洁有序
- 控制单文件代码行数
    • 文件代码超过 200-300行 时需重构封装。
- **架构设计**：考虑代码的可维护性、可扩展性和性能需求
- **命名规范**：使用描述性的变量、函数和类名，反映其用途和含义
- **DRY 原则**：避免重复代码，提取共用逻辑到单独的函数或类
- **注释文档**：为复杂逻辑添加注释，编写清晰的文档说明功能和用法
- **风格一致**：遵循项目或语言的官方风格指南和代码约定
- **利用生态**：优先使用成熟的库和工具，避免不必要的自定义实现。比如taro有很多插件和组件可以优先使用。
- **异常处理**：正确处理边缘情况和错误，提供有用的错误信息 ，可通过react 错误边界的概念实现
- 在 Taro 中尺寸单位建议使用 px、 百分比 %，Taro 默认会对所有单位进行转换
- **mock接口**：基于前后端分离开发原则，前端通过MSW,进行接口mock。

## 生产环境注意事项

### 禁止事项

- ❌ 生产环境不能包含 MSW 代码
- ❌ 不能在生产环境使用 Mock 数据
- ❌ 不能在生产环境输出调试日志

### 构建检查

```typescript
// ✅ 构建时检查
if (process.env.NODE_ENV === 'production' && typeof window !== 'undefined') {
  if (window.location.hostname.includes('mock')) {
    throw new Error('Production build should not include mock services')
  }
}
```

## 代码审查要点

1. **功能完整性**: 是否实现了需求
2. **代码质量**: 是否通过所有检查
3. **性能影响**: 是否影响应用性能
4. **安全性**: 是否存在安全隐患
5. **可维护性**: 代码是否易于理解和维护

## 最终检查

编写完代码，最后需要运行pnpm check 进行代码格式和规范检查，如果遇到错误请修复，修复后需要进行pnpm check 验证，直到解决所有的错误。
