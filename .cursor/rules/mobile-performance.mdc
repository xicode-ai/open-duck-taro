---
alwaysApply: true
---

# 移动端优化和性能规范

## 性能优化规范

### 图片优化

```typescript
// ✅ 图片懒加载
import { Image } from '@tarojs/components'

const OptimizedImage: React.FC<ImageProps> = ({
  src,
  placeholder,
  ...props
}) => {
  return (
    <Image
      src={src}
      lazyLoad
      mode="aspectFit"
      placeholder={placeholder}
      onError={(e) => {
        console.warn('图片加载失败:', e)
      }}
      {...props}
    />
  )
}

// ✅ 图片预加载
const preloadImages = (urls: string[]): Promise<void[]> => {
  return Promise.all(
    urls.map(url => {
      return new Promise<void>((resolve, reject) => {
        const img = new Image()
        img.onload = () => resolve()
        img.onerror = () => reject(new Error(`Failed to load ${url}`))
        img.src = url
      })
    })
  )
}
```

### 音频处理优化

```typescript
// ✅ 录音权限和功能
const useRecording = () => {
  const [isRecording, setIsRecording] = useState(false)

  const startRecording = useCallback(async () => {
    try {
      // 请求录音权限
      const authorized = await Taro.authorize({
        scope: 'scope.record',
      })

      if (authorized.errMsg !== 'authorize:ok') {
        throw new Error('录音权限被拒绝')
      }

      // 开始录音
      const recorderManager = Taro.getRecorderManager()
      recorderManager.start({
        duration: 60000, // 最长60秒
        sampleRate: 16000,
        numberOfChannels: 1,
        encodeBitRate: 48000,
        format: 'mp3',
      })

      setIsRecording(true)
    } catch (error) {
      console.error('录音启动失败:', error)
      Taro.showToast({
        title: '录音功能不可用',
        icon: 'none',
      })
    }
  }, [])

  return { isRecording, startRecording }
}

// ✅ 音频播放优化
const useAudioPlayer = () => {
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [duration, setDuration] = useState(0)

  const playAudio = useCallback((src: string) => {
    const audioContext = Taro.createInnerAudioContext()

    audioContext.src = src
    audioContext.autoplay = true

    audioContext.onPlay(() => {
      setIsPlaying(true)
    })

    audioContext.onPause(() => {
      setIsPlaying(false)
    })

    audioContext.onTimeUpdate(() => {
      setCurrentTime(audioContext.currentTime)
    })

    audioContext.onLoadedMetadata(() => {
      setDuration(audioContext.duration)
    })

    audioContext.onEnded(() => {
      setIsPlaying(false)
      setCurrentTime(0)
    })

    return audioContext
  }, [])

  return { isPlaying, currentTime, duration, playAudio }
}
```

### 列表性能优化

```typescript
// ✅ 虚拟列表实现
const VirtualList: React.FC<VirtualListProps> = ({
  items,
  itemHeight,
  containerHeight,
  renderItem
}) => {
  const [scrollTop, setScrollTop] = useState(0)

  const visibleStart = Math.floor(scrollTop / itemHeight)
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  )

  const visibleItems = items.slice(visibleStart, visibleEnd)
  const offsetY = visibleStart * itemHeight

  return (
    <ScrollView
      scrollY
      style={{ height: containerHeight }}
      onScroll={(e) => setScrollTop(e.detail.scrollTop)}
    >
      <View style={{ height: items.length * itemHeight, position: 'relative' }}>
        <View style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <View key={visibleStart + index} style={{ height: itemHeight }}>
              {renderItem(item, visibleStart + index)}
            </View>
          ))}
        </View>
      </View>
    </ScrollView>
  )
}

// ✅ 长列表优化
const LongList: React.FC<LongListProps> = ({ data, onLoadMore }) => {
  const [loading, setLoading] = useState(false)
  const [hasMore, setHasMore] = useState(true)

  const handleScrollToLower = useCallback(async () => {
    if (loading || !hasMore) return

    setLoading(true)
    try {
      await onLoadMore()
    } finally {
      setLoading(false)
    }
  }, [loading, hasMore, onLoadMore])

  return (
    <ScrollView
      scrollY
      onScrollToLower={handleScrollToLower}
      lowerThreshold={100}
    >
      {data.map((item, index) => (
        <ListItem key={item.id} item={item} index={index} />
      ))}
      {loading && <Loading />}
      {!hasMore && <NoMoreData />}
    </ScrollView>
  )
}
```

## 内存管理优化

### 组件卸载清理

```typescript
// ✅ 清理副作用
const DataComponent: React.FC<DataComponentProps> = ({ userId }) => {
  const [data, setData] = useState(null)

  useEffect(() => {
    let isMounted = true
    const abortController = new AbortController()

    const fetchData = async () => {
      try {
        const response = await fetch(`/api/data/${userId}`, {
          signal: abortController.signal
        })
        const result = await response.json()

        if (isMounted) {
          setData(result)
        }
      } catch (error) {
        if (error.name !== 'AbortError' && isMounted) {
          console.error('Failed to fetch data:', error)
        }
      }
    }

    fetchData()

    return () => {
      isMounted = false
      abortController.abort()
    }
  }, [userId])

  return <div>{data && <DataDisplay data={data} />}</div>
}

// ✅ 定时器清理
const TimerComponent: React.FC = () => {
  const [count, setCount] = useState(0)

  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prev => prev + 1)
    }, 1000)

    return () => {
      clearInterval(timer)
    }
  }, [])

  return <div>Count: {count}</div>
}
```

### 事件监听器管理

```typescript
// ✅ 事件监听器清理
const useEventListener = (
  eventName: string,
  handler: (event: Event) => void,
  element: EventTarget = window
) => {
  const savedHandler = useRef<(event: Event) => void>()

  useEffect(() => {
    savedHandler.current = handler
  }, [handler])

  useEffect(() => {
    const eventListener = (event: Event) => savedHandler.current?.(event)

    element.addEventListener(eventName, eventListener)

    return () => {
      element.removeEventListener(eventName, eventListener)
    }
  }, [eventName, element])
}

// ✅ 使用示例
const ScrollComponent: React.FC = () => {
  const [scrollY, setScrollY] = useState(0)

  useEventListener('scroll', (event) => {
    const target = event.target as Element
    setScrollY(target.scrollTop)
  })

  return <div>Scroll Y: {scrollY}</div>
}
```

## 网络优化

### 请求优化

```typescript
// ✅ 请求去重
class RequestDeduplicator {
  private pendingRequests = new Map<string, Promise<any>>()

  async request<T>(key: string, requestFn: () => Promise<T>): Promise<T> {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key)!
    }

    const promise = requestFn().finally(() => {
      this.pendingRequests.delete(key)
    })

    this.pendingRequests.set(key, promise)
    return promise
  }
}

// ✅ 请求缓存
class RequestCache {
  private cache = new Map<string, { data: any; timestamp: number }>()
  private ttl = 5 * 60 * 1000 // 5分钟

  get<T>(key: string): T | null {
    const cached = this.cache.get(key)
    if (!cached) return null

    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(key)
      return null
    }

    return cached.data
  }

  set<T>(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    })
  }
}
```

### 离线支持

```typescript
// ✅ 离线检测
const useOfflineStatus = () => {
  const [isOffline, setIsOffline] = useState(!navigator.onLine)

  useEffect(() => {
    const handleOnline = () => setIsOffline(false)
    const handleOffline = () => setIsOffline(true)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOffline
}

// ✅ 离线数据存储
const useOfflineStorage = () => {
  const [isOnline] = useOfflineStatus()

  const saveOfflineData = useCallback(
    (key: string, data: any) => {
      if (!isOnline) {
        localStorage.setItem(`offline_${key}`, JSON.stringify(data))
      }
    },
    [isOnline]
  )

  const getOfflineData = useCallback((key: string) => {
    const data = localStorage.getItem(`offline_${key}`)
    return data ? JSON.parse(data) : null
  }, [])

  return { saveOfflineData, getOfflineData }
}
```

## 渲染性能优化

### 组件优化

```typescript
// ✅ 使用 React.memo 避免不必要的重渲染
const UserCard = React.memo<UserCardProps>(({ user, onSelect }) => {
  const handleClick = useCallback(() => {
    onSelect(user.id)
  }, [user.id, onSelect])

  return (
    <div onClick={handleClick}>
      {user.name}
    </div>
  )
})

// ✅ 使用 useMemo 缓存计算结果
const ExpensiveComponent = ({ items }) => {
  const processedItems = useMemo(() => {
    return items.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }))
  }, [items])

  return <div>{processedItems.map(renderItem)}</div>
}

// ✅ 使用 useCallback 缓存函数
const ParentComponent = () => {
  const [count, setCount] = useState(0)

  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1)
  }, [])

  return (
    <div>
      <button onClick={handleIncrement}>Increment</button>
      <ChildComponent onIncrement={handleIncrement} />
    </div>
  )
}
```

### 代码分割

```typescript
// ✅ 页面级代码分割
const LazyUserPage = lazy(() => import('@/pages/user'))
const LazySettingsPage = lazy(() => import('@/pages/settings'))

// ✅ 组件级代码分割 (大型组件)
const LazyChart = lazy(() => import('@/components/Chart'))

// ✅ 路由级别的代码分割
const App = () => {
  return (
    <Router>
      <Suspense fallback={<Loading />}>
        <Routes>
          <Route path="/user" element={<LazyUserPage />} />
          <Route path="/settings" element={<LazySettingsPage />} />
        </Routes>
      </Suspense>
    </Router>
  )
}
```

## 移动端特定优化

### 触摸优化

```typescript
// ✅ 触摸事件优化
const TouchOptimizedButton: React.FC<ButtonProps> = ({ onClick, children }) => {
  const [isPressed, setIsPressed] = useState(false)

  const handleTouchStart = useCallback((e: TouchEvent) => {
    e.preventDefault()
    setIsPressed(true)
  }, [])

  const handleTouchEnd = useCallback((e: TouchEvent) => {
    e.preventDefault()
    setIsPressed(false)
    onClick?.(e as any)
  }, [onClick])

  return (
    <button
      className={`touch-button ${isPressed ? 'pressed' : ''}`}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
    >
      {children}
    </button>
  )
}
```

### 滚动优化

```typescript
// ✅ 滚动性能优化
const OptimizedScrollView: React.FC<ScrollViewProps> = ({ children, ...props }) => {
  const [isScrolling, setIsScrolling] = useState(false)

  const handleScroll = useCallback(
    throttle((e: any) => {
      setIsScrolling(true)
      // 滚动处理逻辑
    }, 16), // 60fps
    []
  )

  const handleScrollEnd = useCallback(
    debounce(() => {
      setIsScrolling(false)
    }, 150),
    []
  )

  return (
    <ScrollView
      {...props}
      onScroll={handleScroll}
      onScrollEnd={handleScrollEnd}
      scrollWithAnimation={false}
      enhanced
      showScrollbar={false}
    >
      {children}
    </ScrollView>
  )
}
```

## 性能监控

### 性能指标收集

```typescript
// ✅ 性能监控
class PerformanceMonitor {
  private metrics: Map<string, number> = new Map()

  startTiming(name: string): void {
    this.metrics.set(name, performance.now())
  }

  endTiming(name: string): number {
    const startTime = this.metrics.get(name)
    if (!startTime) return 0

    const duration = performance.now() - startTime
    this.metrics.delete(name)

    // 发送性能数据
    this.sendMetric(name, duration)

    return duration
  }

  private sendMetric(name: string, value: number): void {
    // 发送到性能监控服务
    console.log(`Performance: ${name} = ${value}ms`)
  }
}

// ✅ 使用示例
const DataComponent: React.FC = () => {
  const monitor = useRef(new PerformanceMonitor())

  useEffect(() => {
    monitor.current.startTiming('data-load')

    fetchData().then(() => {
      const duration = monitor.current.endTiming('data-load')
      console.log(`Data loaded in ${duration}ms`)
    })
  }, [])

  return <div>Data loaded</div>
}
```

### 内存监控

```typescript
// ✅ 内存使用监控
const useMemoryMonitor = () => {
  const [memoryInfo, setMemoryInfo] = useState<any>(null)

  useEffect(() => {
    const checkMemory = () => {
      if ('memory' in performance) {
        setMemoryInfo(performance.memory)
      }
    }

    checkMemory()
    const interval = setInterval(checkMemory, 5000)

    return () => clearInterval(interval)
  }, [])

  return memoryInfo
}
```

## 最佳实践总结

### 性能优化检查清单

- [ ] 图片使用懒加载
- [ ] 长列表使用虚拟滚动
- [ ] 组件使用 React.memo 优化
- [ ] 计算使用 useMemo 缓存
- [ ] 函数使用 useCallback 缓存
- [ ] 及时清理定时器和事件监听器
- [ ] 使用代码分割减少初始包大小
- [ ] 网络请求使用缓存和去重
- [ ] 移动端触摸事件优化
- [ ] 滚动性能优化
