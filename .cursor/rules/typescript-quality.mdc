---
alwaysApply: true
---

# TypeScript 和代码质量规范

## TypeScript 严格模式

### 类型定义要求

```typescript
// ✅ 完整的接口定义
interface ButtonProps {
  type?: 'primary' | 'secondary' | 'danger'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  loading?: boolean
  children: React.ReactNode
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
}

// ✅ 泛型使用
interface ApiResponse<T> {
  code: number
  message: string
  data: T
}

// ✅ 联合类型
type Theme = 'light' | 'dark'
type UserRole = 'admin' | 'user' | 'guest'

// ✅ 工具类型
type PartialUser = Partial<User>
type RequiredUser = Required<User>
type UserEmail = Pick<User, 'email'>
type UserWithoutId = Omit<User, 'id'>
```

### 禁止的类型使用

```typescript
// ❌ 禁止使用 any
const data: any = {} // 禁止

// ❌ 禁止使用 object
const config: object = {} // 禁止，使用具体接口

// ❌ 禁止使用 Function
const callback: Function = () => {} // 禁止，使用具体函数签名

// ❌ 禁止使用 unknown 而不进行类型检查
const result: unknown = getData()
// 应该先进行类型检查
if (typeof result === 'string') {
  // 使用 result
}
```

### 类型断言规范

```typescript
// ✅ 安全的类型断言
const element = document.getElementById('myElement') as HTMLInputElement

// ✅ 使用类型守卫
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

if (isString(value)) {
  // 这里 value 被推断为 string 类型
  console.log(value.toUpperCase())
}

// ❌ 避免强制类型断言
const data = someValue as any // 禁止
```

## 代码质量规范

### 函数定义规范

```typescript
// ✅ 函数参数类型定义
function calculateTotal(
  items: CartItem[],
  discount: number = 0,
  taxRate: number = 0.1
): number {
  const subtotal = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  )
  const discountAmount = subtotal * discount
  const tax = (subtotal - discountAmount) * taxRate
  return subtotal - discountAmount + tax
}

// ✅ 异步函数类型定义
async function fetchUserData(userId: string): Promise<User | null> {
  try {
    const response = await userApi.getUserInfo(userId)
    return response.data
  } catch (error) {
    console.error('Failed to fetch user data:', error)
    return null
  }
}

// ✅ 回调函数类型定义
type EventHandler<T = Event> = (event: T) => void
type AsyncEventHandler<T = Event> = (event: T) => Promise<void>

const handleClick: EventHandler<MouseEvent> = event => {
  console.log('Clicked at:', event.clientX, event.clientY)
}
```

### 类定义规范

```typescript
// ✅ 类定义和访问修饰符
class UserService {
  private httpClient: HttpClient
  private cache: Map<string, User> = new Map()

  constructor(httpClient: HttpClient) {
    this.httpClient = httpClient
  }

  // 公共方法
  public async getUser(id: string): Promise<User | null> {
    // 检查缓存
    if (this.cache.has(id)) {
      return this.cache.get(id)!
    }

    try {
      const user = await this.httpClient.get<User>(`/users/${id}`)
      this.cache.set(id, user)
      return user
    } catch (error) {
      console.error('Failed to fetch user:', error)
      return null
    }
  }

  // 私有方法
  private validateUser(user: User): boolean {
    return !!(user.id && user.name && user.email)
  }

  // 受保护方法
  protected clearCache(): void {
    this.cache.clear()
  }
}
```

### 接口和类型定义规范

```typescript
// ✅ 接口定义
interface User {
  readonly id: string
  name: string
  email: string
  avatar?: string
  createdAt: Date
  updatedAt: Date
}

// ✅ 接口继承
interface AdminUser extends User {
  role: 'admin'
  permissions: Permission[]
}

// ✅ 接口合并
interface User {
  lastLoginAt?: Date
}

// ✅ 类型别名
type UserId = string
type UserStatus = 'active' | 'inactive' | 'suspended'
type UserWithStatus = User & { status: UserStatus }

// ✅ 条件类型
type NonNullable<T> = T extends null | undefined ? never : T
type ApiResponse<T> = T extends string ? { message: T } : { data: T }
```

## 代码组织规范

### 导入导出规范

```typescript
// ✅ 导入顺序
// 1. Node 模块
import React from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'

// 2. 第三方库
import { useQuery } from '@tanstack/react-query'
import { create } from 'zustand'

// 3. 内部模块（按路径深度排序）
import { userApi } from '@/services/api'
import { useUserStore } from '@/stores/user'
import { Button } from '@/components/common/Button'

// 4. 相对导入
import './index.scss'
import { formatDate } from '../utils/date'

// ✅ 命名导出
export const UserCard: React.FC<UserCardProps> = ({ user }) => {
  // 组件实现
}

export type { UserCardProps }

// ✅ 默认导出
const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  // 组件实现
}

export default UserProfile
```

### 模块化规范

```typescript
// ✅ 工具函数模块
// utils/validation.ts
export const validators = {
  email: (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  },

  phone: (phone: string): boolean => {
    const phoneRegex = /^1[3-9]\d{9}$/
    return phoneRegex.test(phone)
  },

  required: (value: any): boolean => {
    return value !== null && value !== undefined && value !== ''
  },
} as const

// ✅ 常量模块
// constants/index.ts
export const API_ENDPOINTS = {
  USER: '/api/user',
  TOPICS: '/api/topics',
  VOCABULARY: '/api/vocabulary',
} as const

export const STORAGE_KEYS = {
  TOKEN: 'auth_token',
  USER_INFO: 'user_info',
  SETTINGS: 'user_settings',
} as const

// ✅ 类型定义模块
// types/api.ts
export interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
}

export interface PaginatedResponse<T> {
  code: number
  message: string
  data: {
    items: T[]
    total: number
    page: number
    pageSize: number
  }
}
```

## 错误处理规范

### 错误类型定义

```typescript
// ✅ 自定义错误类
class ApiError extends Error {
  public readonly status: number
  public readonly code: string
  public readonly details?: any

  constructor(message: string, status: number, code: string, details?: any) {
    super(message)
    this.name = 'ApiError'
    this.status = status
    this.code = code
    this.details = details
  }
}

class ValidationError extends Error {
  public readonly field: string
  public readonly value: any

  constructor(field: string, value: any, message: string) {
    super(message)
    this.name = 'ValidationError'
    this.field = field
    this.value = value
  }
}

// ✅ 错误类型联合
type AppError = ApiError | ValidationError | Error

// ✅ 错误处理函数
function handleError(error: AppError): void {
  if (error instanceof ApiError) {
    console.error(`API Error [${error.status}]:`, error.message)
    // 处理 API 错误
  } else if (error instanceof ValidationError) {
    console.error(`Validation Error in ${error.field}:`, error.message)
    // 处理验证错误
  } else {
    console.error('Unknown error:', error.message)
    // 处理未知错误
  }
}
```

### 异步错误处理

```typescript
// ✅ Promise 错误处理
async function fetchData(): Promise<Data | null> {
  try {
    const response = await api.getData()
    return response.data
  } catch (error) {
    handleError(error as AppError)
    return null
  }
}

// ✅ 使用 Result 模式
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E }

async function fetchDataSafely(): Promise<Result<Data, ApiError>> {
  try {
    const response = await api.getData()
    return { success: true, data: response.data }
  } catch (error) {
    return { success: false, error: error as ApiError }
  }
}
```

## 性能优化规范

### 类型优化

```typescript
// ✅ 使用 const assertions
const colors = ['red', 'green', 'blue'] as const
type Color = (typeof colors)[number] // 'red' | 'green' | 'blue'

// ✅ 使用 satisfies 操作符
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3,
} satisfies ApiConfig

// ✅ 避免重复类型定义
interface BaseEntity {
  id: string
  createdAt: Date
  updatedAt: Date
}

interface User extends BaseEntity {
  name: string
  email: string
}

interface Product extends BaseEntity {
  title: string
  price: number
}
```

### 内存优化

```typescript
// ✅ 使用 WeakMap 避免内存泄漏
const userCache = new WeakMap<User, UserProfile>()

// ✅ 及时清理定时器
class TimerManager {
  private timers: Set<NodeJS.Timeout> = new Set()

  setTimer(callback: () => void, delay: number): NodeJS.Timeout {
    const timer = setTimeout(() => {
      callback()
      this.timers.delete(timer)
    }, delay)

    this.timers.add(timer)
    return timer
  }

  clearAllTimers(): void {
    this.timers.forEach(timer => clearTimeout(timer))
    this.timers.clear()
  }
}
```

## 代码审查要点

### 类型安全检查

1. **避免 any 类型**: 所有变量都应该有明确的类型
2. **使用严格模式**: 启用所有 TypeScript 严格检查
3. **类型断言安全**: 确保类型断言是安全的
4. **泛型使用**: 合理使用泛型提高代码复用性

### 代码质量检查

1. **函数复杂度**: 单个函数不超过 20 行
2. **文件大小**: 单个文件不超过 300 行
3. **命名规范**: 使用描述性的变量和函数名
4. **注释完整**: 复杂逻辑必须有注释说明

### 性能检查

1. **避免不必要的重渲染**: 使用 React.memo 和 useMemo
2. **内存泄漏**: 及时清理事件监听器和定时器
3. **类型计算**: 避免在渲染过程中进行复杂计算
4. **依赖优化**: 合理设置 useEffect 和 useMemo 的依赖数组

## 代码格式化规范

### Prettier 配置

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### ESLint 配置

```json
{
  "extends": ["@typescript-eslint/recommended", "prettier"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "prefer-const": "error",
    "no-var": "error"
  }
}
```

## 最终检查清单

- [ ] 所有变量都有明确的类型定义
- [ ] 没有使用 any 类型
- [ ] 函数参数和返回值都有类型注解
- [ ] 接口和类型定义完整
- [ ] 错误处理完善
- [ ] 代码格式符合规范
- [ ] 没有 ESLint 错误
- [ ] 没有 TypeScript 编译错误
